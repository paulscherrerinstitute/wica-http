/*- Package Declaration ------------------------------------------------------*/

package ch.psi.wica.controlsystem.epics.channel;

/*- Imported packages --------------------------------------------------------*/

import ch.psi.wica.controlsystem.event.channel.EpicsChannelEventPublisher;
import ch.psi.wica.model.app.StatisticsCollectionService;
import net.jcip.annotations.ThreadSafe;
import org.apache.commons.lang3.Validate;
import org.epics.ca.Channel;
import org.epics.ca.Context;
import org.epics.ca.impl.LibraryConfiguration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;

/*- Interface Declaration ----------------------------------------------------*/
/*- Class Declaration --------------------------------------------------------*/

/**
 * A service which establishes EPICS CA channels on user-specified channels of
 * interest, subsequently publishing changes in the channel's connection state
 * to interested consumers within the application.
 *
 * @implNote.
 * The current implementation uses PSI's CA EPICS client library to create a
 * single shared EPICS CA Context per class instance. The EPICS CA context and
 * all associated resources are disposed of when the service instance is closed.
 */
@Component
@ThreadSafe
public class EpicsChannelManager implements AutoCloseable
{

/*- Public attributes --------------------------------------------------------*/
/*- Private attributes -------------------------------------------------------*/

   private final Logger logger = LoggerFactory.getLogger( EpicsChannelManager.class );

   private final Context caContext;

   private final Map<EpicsChannelName, Channel<Object>> monitoredChannels;
   private final Map<EpicsChannelName, Channel<Object>> polledChannels;

   private final EpicsChannelConnectionChangeSubscriber epicsChannelConnectionChangeSubscriber;
   private final EpicsChannelEventPublisher epicsChannelEventPublisher;

   private final EpicsChannelManagerStatistics statisticsCollector;

/*- Main ---------------------------------------------------------------------*/
/*- Constructor --------------------------------------------------------------*/

   /**
    * Constructs a new instance.
    *
    * @param epicsCaLibraryMonitorNotifierImpl the CA library monitor notifier configuration.
    * @param epicsCaLibraryDebugLevel the CA library debug level.
    * @param epicsChannelConnectionChangeSubscriber an object which can be used to subscribe to connection state changes.
    * @param epicsChannelEventPublisher an object which publishes events of interest to consumers within the application.
    * @param statisticsCollectionService an object which will collect the statistics associated with this class instance.
    */
   public EpicsChannelManager( @Value( "${wica.epics-ca-library-monitor-notifier-impl}") String  epicsCaLibraryMonitorNotifierImpl,
                               @Value( "${wica.epics-ca-library-debug-level}") int epicsCaLibraryDebugLevel,
                               @Autowired EpicsChannelConnectionChangeSubscriber epicsChannelConnectionChangeSubscriber,
                               @Autowired EpicsChannelEventPublisher epicsChannelEventPublisher,
                               @Autowired StatisticsCollectionService statisticsCollectionService )
   {
      logger.debug( "'{}' - constructing new EpicsChannelManager instance...", this );

      this.epicsChannelConnectionChangeSubscriber=Validate.notNull( epicsChannelConnectionChangeSubscriber );
      this.epicsChannelEventPublisher = Validate.notNull( epicsChannelEventPublisher );

      this.monitoredChannels = new ConcurrentHashMap<>();
      this.polledChannels = new ConcurrentHashMap<>();

      this.statisticsCollector = new EpicsChannelManagerStatistics( monitoredChannels, polledChannels );
      statisticsCollectionService.addCollectable( statisticsCollector );

      // Setup a context that uses the monitor notification policy and debug
      // message log level defined in the configuration file.
      final Properties properties = new Properties();
      properties.setProperty( LibraryConfiguration.PropertyNames.CA_MONITOR_NOTIFIER_IMPL.toString(), epicsCaLibraryMonitorNotifierImpl );
      properties.setProperty( LibraryConfiguration.PropertyNames.CA_LIBRARY_LOG_LEVEL.toString(), String.valueOf( epicsCaLibraryDebugLevel ) );

      //System.setProperty( "EPICS_CA_ADDR_LIST", "192.168.0.46:5064" );
      //System.setProperty( "EPICS_CA_ADDR_LIST", "129.129.145.206:5064" );
      //System.setProperty( "EPICS_CA_ADDR_LIST", "proscan-cagw:5062" );

      caContext = new Context( properties );
      logger.debug( "'{}' - service instance constructed ok.", this );
   }

/*- Class methods ------------------------------------------------------------*/
/*- Public methods -----------------------------------------------------------*/

   public EpicsChannelManagerStatistics getStatistics()
   {
      return statisticsCollector;
   }

   public void createMonitoredChannel( EpicsChannelName epicsChannelName )
   {
      Validate.notNull( epicsChannelName );
      statisticsCollector.incrementCreateMonitoredChannelRequests();

      if ( ( monitoredChannels.containsKey( epicsChannelName ) ) )
      {
         logger.info("'{}' - monitored channel with this name already exists - nothing to do.", epicsChannelName );
         return;
      }
      else if ( polledChannels.containsKey( epicsChannelName ) )
      {
         logger.info("'{}' - polled channel with this name already exists - copying channel reference", epicsChannelName );
         monitoredChannels.put( epicsChannelName, polledChannels.get( epicsChannelName) );
         return;
      }

      logger.info("'{}' - creating new channel...", epicsChannelName );
      final Channel<Object> caChannel = createChannel( epicsChannelName );
      monitoredChannels.put( epicsChannelName, caChannel );
   }

   public void removeMonitoredChannel( EpicsChannelName epicsChannelName )
   {
      Validate.notNull( epicsChannelName );
      Validate.validState( monitoredChannels.containsKey(  epicsChannelName ) );

      statisticsCollector.incrementRemoveMonitoredChannelRequests();

      final Channel<Object> caChannel = monitoredChannels.remove( epicsChannelName );
      if ( ! polledChannels.containsKey( epicsChannelName ) )
      {
         caChannel.close();
      }
   }

   public void createPolledChannel( EpicsChannelName epicsChannelName )
   {
      Validate.notNull( epicsChannelName );
      statisticsCollector.incrementCreatePolledChannelRequests();

      if ( ( polledChannels.containsKey( epicsChannelName ) ) )
      {
         logger.info("'{}' - polled channel with this name already exists - nothing to do.", epicsChannelName );
         return;
      }
      else if ( monitoredChannels.containsKey( epicsChannelName ) )
      {
         logger.info("'{}' - monitored channel with this name already exists - copying channel reference.", epicsChannelName );
         polledChannels.put( epicsChannelName, monitoredChannels.get( epicsChannelName) );
         return;
      }

      logger.info("'{}' - creating new channel...", epicsChannelName );
      final Channel<Object> caChannel = createChannel( epicsChannelName );
      polledChannels.put( epicsChannelName, caChannel );
   }

   public void removePolledChannel( EpicsChannelName epicsChannelName )
   {
      Validate.notNull( epicsChannelName );
      Validate.validState( polledChannels.containsKey(  epicsChannelName ) );

      statisticsCollector.incrementRemovePolledChannelRequests();

      final Channel<Object> caChannel = polledChannels.remove( epicsChannelName );
      if ( ! monitoredChannels.containsKey( epicsChannelName ) )
      {
         caChannel.close();
      }
   }

   /**
    * Disposes of all resources associated with this class instance.
    */
   @Override
   public void close()
   {
      // Dispose of any references that are no longer required
      logger.debug( "'{}' - disposing resources...", this );

      // Note: closing the context automatically disposes of any open channels and monitors.
      caContext.close();
      monitoredChannels.clear();
      polledChannels.clear();

      logger.debug( "'{}' - resources disposed ok.", this );
   }

/*- Private methods ----------------------------------------------------------*/

   /**
    * Creates a new EPICS channel and starts publishing events describing
    * the channel's evolving connection state.
    *
    * The EPICS channel may or may not be online when this method is invoked.
    * The connection-state-change event will be published when the connection to
    * the remote IOC is eventually established. Subsequently, the value-change
    * event will be published to provide the latest value of the channel.
    *
    * @param epicsChannelName the request specification object.
    * @throws NullPointerException if the 'epicsChannelName' argument was null.
    */
   private Channel<Object> createChannel( EpicsChannelName epicsChannelName )
   {
      Validate.notNull( epicsChannelName );

      logger.info("'{}' - creating channel... ", epicsChannelName );
      final Channel<Object> caChannel;
      try
      {
         logger.trace("'{}' - creating channel of type 'generic'...", epicsChannelName );
         caChannel = caContext.createChannel( epicsChannelName.asString(), Object.class);
         logger.trace("'{}' - channel created ok.", epicsChannelName );

         // Synchronously add a connection listener before making any attempt to connect the channel.
         logger.trace("'{}' - adding connection change listener... ", epicsChannelName );
         epicsChannelConnectionChangeSubscriber.subscribe( caChannel, (conn) -> {
            if ( conn )
            {
               epicsChannelEventPublisher.publishChannelConnected( caChannel );
            }
            else
            {
               epicsChannelEventPublisher.publishChannelDisconnected( caChannel );
            }
         } );
         logger.trace("'{}' - connection change listener added ok.", epicsChannelName );

         logger.trace("'{}' - connecting asynchronously... ", epicsChannelName );
         caChannel.connectAsync().thenRunAsync( () -> {
            // Note the CA current (1.2.2) implementation of the CA library calls back
            // this code block using MULTIPLE threads taken from the so-called LeaderFollowersThreadPool.
            // By default this pool is configured for FIVE threads but where necessary this can be
            // increased by setting the system property shown below:
            // System.setProperty( "LeaderFollowersThreadPool.thread_pool_size", "50" );
            logger.trace("'{}' - asynchronous connect completed. Waiting for channel to come online.", epicsChannelName );
            epicsChannelEventPublisher.publishFirstConnected( caChannel );
         } )
         .exceptionally( (ex) -> {
            logger.warn("'{}' - exception on channel, details were as follows: {}", this, ex.toString());
            return null;
         } );
      }
      catch ( Exception ex )
      {
         logger.error("'{}' - exception whilst creating channel, details were as follows: {}", epicsChannelName, ex.toString() );
         throw ex;
      }

      logger.info("'{}' - channel created ok.", epicsChannelName );
      return caChannel;
   }


/*- Nested Classes -----------------------------------------------------------*/

}
